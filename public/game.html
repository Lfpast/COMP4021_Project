<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Game</title>
		<style>
		body {
			display: flex;
			flex-direction: column;
			align-items: center;
			height: 100vh;
			margin: 0;
			font-family: sans-serif;
		}
		#controls {
			padding: 20px;
			background: #f5f5f5;
			width: 100%;
			box-sizing: border-box;
			text-align: center;
			border-bottom: 1px solid #ddd;
		}
		#game-container {
			flex-grow: 1;
			display: flex;
			justify-content: center;
			align-items: center;
			width: 100%;
			overflow: hidden;
		}
		#canvas-container {
			position: relative;
			width: fit-content;
			height: fit-content;
			cursor: none;
		}
		#canvas,
		#canvasFocus,
		.cursor-canvas,
		.signal-canvas {
			position: absolute;
			left: 0;
			top: 0;
		}

		@keyframes shake {
			0% {
				transform: translate(0, 0);
			}
			25% {
				transform: translate(4px, 0px);
			}
			50% {
				transform: translate(0, 0);
			}
			75% {
				transform: translate(-4px, 0px);
			}
			100% {
				transform: translate(0, 0);
			}
		}

		.signal-canvas {
			animation: shake 0.5s infinite;
			z-index: 3;
			pointer-events: none;
		}
		.cursor-canvas {
			z-index: 2;
			pointer-events: none;
		}
		#canvasFocus {
			z-index: 1;
			pointer-events: none;
		}
		#canvas {
			z-index: 0;
		}
		#canvas-background {
			z-index: -1;
		}

		#cursor {
			position: fixed;
			left: -100vh;
			top: -100vh;
			pointer-events: none;

			z-index: 100;
		}
		</style>
	</head>
	<body>
		<div id="controls">
			<form id="join-form">
				<input type="text" id="user" placeholder="Username" required>
				<input type="text" id="room" placeholder="Room ID" required>
				<button type="submit">Join Game</button>
			</form>
		</div>
		<div id="game-container">
			<div id="canvas-container">
				<canvas id="canvas" width="512" height="512"></canvas>
				<canvas id="canvas" width="512" height="512"></canvas>
				<canvas id="canvasFocus" width="512" height="512"></canvas>
			</div>
		</div>
		<canvas id="cursor" width="32" height="32"></canvas>
		<script
			src="https://code.jquery.com/jquery-3.7.1.min.js"
			crossorigin="anonymous"
		></script>
		<script
			src="https://cdn.socket.io/4.8.1/socket.io.min.js"
			integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+"
			crossorigin="anonymous"
		></script>
		<script type="importmap">
		{
			"imports": {
				"es-toolkit": "https://esm.sh/es-toolkit@%5E1"
			}
		}
		</script>
		<script type="module">
		// Pixels Per Tile
		const PPT = 32;

		const canvas = $("#canvas")[0];
		const canvasFocus = $("#canvasFocus")[0];
		const canvasCursor = $("#cursor");
		const canvasContainer = $("#canvas-container");

		const cursorCanvases = [];
		const cursorCanvasCtx = [];
		for (let i = 0; i < 8; i++) {
			const c = $("<canvas></canvas>").attr({
				id: `cursor-canvas-${i}`,
				class: "cursor-canvas",
			});
			cursorCanvases.push(c);
			cursorCanvasCtx.push(c[0].getContext("2d"));
			canvasContainer.append(c);
		}

		const form = $("#join-form");
		const userInput = $("#user");
		const roomInput = $("#room");

		const Cells = new Image();
		Cells.src = "./assets/Cells.png";

		const Grids = new Image();
		Grids.src = "./assets/Grids.png";

		const UI = new Image();
		UI.src = "./assets/UI.png";

		const Players = new Image();
		Players.src = "./assets/Players.png";

		const ctx = canvas.getContext("2d");
		const ctxPress = canvasFocus.getContext("2d");
		const ctxCursor = canvasCursor[0].getContext("2d");

		form.on("submit", (e) => {
			e.preventDefault();
			const user = userInput.val();
			const room = roomInput.val();

			const socket = io({
				query: {
					user,
					room,
				},
			});

			socket.on("connect", () => {
				console.log("Connected to server.");
			});

			socket.on("disconnect", () => {
				console.log("Disconnected from server.");
			});

			/**
			 * Convert the board to a plain object representation.
			 *
			 * @typedef {{w: number, h: number, tiles: Tile[][], visible: boolean[][], flag: boolean[][]}} PlainBoard
			 * @type {PlainBoard}
			 */
			let board;

			const type = (x, y) => {
				if (board.visible[x][y]) {
					const tile = board.tiles[x][y];
					if (tile.t === "EMP") {
						return 0;
					}
					if (tile.t === "NUM") {
						return tile.n;
					}
					if (tile.t === "MIN") {
						return "mine";
					}
				} else {
					if (board.flag[x][y]) {
						return "flag";
					} else {
						return "hidden";
					}
				}
				throw new Error("Unreachable");
			};

			/**
			 * @param {number} x
			 * @param {number} y
			 */
			const draw = (x, y) => {
				if (x < 0 || x >= board.w || y < 0 || y >= board.h) {
					return;
				}

				const t = type(x, y);
				ctx.imageSmoothingEnabled = false;
				switch (t) {
					case 0:
						ctx.drawImage(
							Grids,
							0 * 16,
							0 * 16,
							16,
							16,
							x * PPT,
							y * PPT,
							PPT,
							PPT,
						);
						break;
					case "hidden":
						ctx.drawImage(
							Cells,
							3 * 16,
							4 * 16,
							16,
							16,
							x * PPT,
							y * PPT,
							PPT,
							PPT,
						);
						break;
					case "mine":
						ctx.drawImage(
							Cells,
							2 * 16,
							4 * 16,
							16,
							16,
							x * PPT,
							y * PPT,
							PPT,
							PPT,
						);
						break;
					case "flag":
						ctx.drawImage(
							Cells,
							0 * 16,
							4 * 16,
							16,
							16,
							x * PPT,
							y * PPT,
							PPT,
							PPT,
						);
						break;
					default:
						ctx.drawImage(
							Cells,
							(t - 1) * 16,
							0 * 16,
							16,
							16,
							x * PPT,
							y * PPT,
							PPT,
							PPT,
						);
				}
			};

			/**
			 * @param {number} x
			 * @param {number} y
			 * @param {Partial<{n: number}>} opts
			 */
			const drawFocus = (x, y, opts = {}) => {
				if (x < 0 || x >= board.w || y < 0 || y >= board.h) {
					return;
				}

				const { n = 0 } = opts;
				const ctxCursor = cursorCanvasCtx[n];

				ctxCursor.imageSmoothingEnabled = false;
				ctxCursor.globalCompositeOperation = "multiply";
				ctxCursor.globalAlpha = 0.75;

				ctxCursor.clearRect(0, 0, canvas.width, canvas.height);
				ctxCursor.drawImage(
					Players,
					n * 6 * 16,
					3 * 16,
					16 * 3,
					16 * 3,
					(x - 1) * PPT,
					(y - 1) * PPT,
					PPT * 3,
					PPT * 3,
				);
			};

			/**
			 * @param {number} x
			 * @param {number} y
			 * @param {Partial<{clear: boolean, rec: boolean}>} opts
			 */
			const drawPress = (x, y, opts = {}) => {
				if (x < 0 || x >= board.w || y < 0 || y >= board.h) {
					return;
				}

				const { clear = false, rec = true } = opts;

				ctxPress.imageSmoothingEnabled = false;

				if (clear) {
					ctxPress.clearRect(0, 0, canvas.width, canvas.height);
					return;
				}

				const t = type(x, y);
				switch (t) {
					case 0:
						break;
					case "hidden":
						ctxPress.drawImage(
							Grids,
							1 * 16,
							1 * 16,
							16,
							16,
							x * PPT,
							y * PPT,
							PPT,
							PPT,
						);
						break;
					case "mine":
						break;
					case "flag":
						break;
					default:
						if (rec) {
							drawPress(x - 1, y - 1, { rec: false });
							drawPress(x, y - 1, { rec: false });
							drawPress(x + 1, y - 1, { rec: false });
							drawPress(x - 1, y, { rec: false });
							drawPress(x + 1, y, { rec: false });
							drawPress(x - 1, y + 1, { rec: false });
							drawPress(x, y + 1, { rec: false });
							drawPress(x + 1, y + 1, { rec: false });
						}
				}
			};

			socket.on("init board", ({ w, h }) => {
				console.log(`Initialize board with width: ${w}, height: ${h}`);
				canvas.width = w * PPT;
				canvas.height = h * PPT;
				canvasFocus.width = w * PPT;
				canvasFocus.height = h * PPT;
				canvasContainer.css("width", `${w * PPT}px`);
				canvasContainer.css("height", `${h * PPT}px`);
				for (const c of cursorCanvases) {
					c.attr("width", w * PPT);
					c.attr("height", h * PPT);
				}

				let prevFocusX = -1;
				let prevFocusY = -1;
				canvas.addEventListener("mousemove", (event) => {
					ctxCursor.imageSmoothingEnabled = false;
					ctxCursor.drawImage(UI, 1 * 16, 4 * 16, 16, 16, 0, 0, 32, 32);

					canvasCursor.css("left", `${event.clientX - 6}px`);
					canvasCursor.css("top", `${event.clientY}px`);

					const x = Math.floor(event.offsetX / PPT);
					const y = Math.floor(event.offsetY / PPT);

					if (x === prevFocusX && y === prevFocusY) {
						return;
					}

					prevFocusX = x;
					prevFocusY = y;

					socket.emit("move", { x, y });
				});
				socket.on("move", ({ ui, x, y }) => {
					drawFocus(x, y, { n: ui });
				});

				let mdx = -1;
				let mdy = -1;
				let mdxx = -1;
				let mdyy = -1;
				canvas.addEventListener("mousedown", (event) => {
					const x = Math.floor(event.offsetX / PPT);
					const y = Math.floor(event.offsetY / PPT);

					mdx = x;
					mdy = y;
					mdxx = event.offsetX / PPT;
					mdyy = event.offsetY / PPT;

					drawPress(x, y);
				});

				canvas.addEventListener("mouseup", (event) => {
					const x = Math.floor(event.offsetX / PPT);
					const y = Math.floor(event.offsetY / PPT);

					drawPress(mdx, mdy, { clear: true });

					if (x === mdx && y === mdy) {
						if (event.button === 0) {
							const x = Math.floor(event.offsetX / PPT);
							const y = Math.floor(event.offsetY / PPT);
							socket.emit("reveal", { x, y });
						} else {
							const x = Math.floor(event.offsetX / PPT);
							const y = Math.floor(event.offsetY / PPT);
							socket.emit("flag", { x, y });
						}
					}

					if (x !== mdx || y !== mdy) {
						const xx = event.offsetX / PPT;
						const yy = event.offsetY / PPT;

						// calculate the vector
						const dx = xx - mdxx;
						const dy = yy - mdyy;
						// calculate the angle;
						const angle = Math.atan2(dy, dx);
						// determine the direction
						console.log(`Angle: ${angle}`);
						if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
							socket.emit("signal", { type: "on-my-way", x: mdxx, y: mdyy });
						}
						if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) {
							socket.emit("signal", { type: "help-me", x: mdxx, y: mdyy });
						}
						if (angle >= (3 * Math.PI) / 4 || angle < (-3 * Math.PI) / 4) {
							socket.emit("signal", {
								type: "what-are-you-doing",
								x: mdxx,
								y: mdyy,
							});
						}
						if (angle >= (-3 * Math.PI) / 4 && angle < -Math.PI / 4) {
							socket.emit("signal", { type: "dont-do", x: mdxx, y: mdyy });
						}
					}
				});

				socket.on("signal", ({ type, x, y }) => {
					console.log(`Received signal ${type} at (${x}, ${y})`);
					const signalCanvas = $("<canvas></canvas>").attr({
						class: "signal-canvas",
					});
					signalCanvas.attr("width", canvas.width);
					signalCanvas.attr("height", canvas.height);

					canvasContainer.append(signalCanvas);

					const signalCtx = signalCanvas[0].getContext("2d");
					signalCtx.imageSmoothingEnabled = false;

					switch (type) {
						case "on-my-way":
							signalCtx.drawImage(
								UI,
								0 * 16,
								0 * 16,
								16,
								16,
								(x - 0.5) * PPT,
								(y - 0.5) * PPT,
								PPT,
								PPT,
							);
							break;
						case "dont-do":
							signalCtx.drawImage(
								UI,
								1 * 16,
								0 * 16,
								16,
								16,
								(x - 0.5) * PPT,
								(y - 0.5) * PPT,
								PPT,
								PPT,
							);
							break;
						case "help-me":
							signalCtx.drawImage(
								UI,
								1 * 16,
								1 * 16,
								16,
								16,
								(x - 0.5) * PPT,
								(y - 0.5) * PPT,
								PPT,
								PPT,
							);
							break;
						case "what-are-you-doing":
							signalCtx.drawImage(
								UI,
								4 * 16,
								0 * 16,
								16,
								16,
								(x - 0.5) * PPT,
								(y - 0.5) * PPT,
								PPT,
								PPT,
							);
							break;
						default:
							throw new Error("Unreachable");
					}

					signalCanvas.fadeOut(1500, () => {
						signalCanvas.remove();
					});
				});

				canvas.addEventListener("contextmenu", (event) => {
					event.preventDefault();
				});
				$("#game-container").on("contextmenu", (event) => {
					event.preventDefault();
				});
				$("body").on("contextmenu", (event) => {
					event.preventDefault();
				});
			});

			socket.on("update board", ({ b, cs }) => {
				board = b;
				cs.forEach(([x, y]) => {
					draw(x, y);
				});
			});
		});
		</script>
	</body>
</html>
